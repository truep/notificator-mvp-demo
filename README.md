# Notification MVP Service

MVP сервиса уведомлений на Go с использованием Redis Streams для доставки сообщений в реальном времени через WebSocket.

## Архитектура

Сервис построен на принципах чистой архитектуры и состоит из следующих компонентов:

- **HTTP API** - принимает запросы на создание уведомлений через `POST /api/v1/notify`
- **WebSocket Gateway** - обеспечивает доставку уведомлений клиентам в реальном времени
- **Redis Streams** - персональные потоки для каждого пользователя с Consumer Groups
- **TTL Janitor** - фоновый воркер для удаления просроченных уведомлений (15 минут)
- **Group Maintenance** - воркер для обслуживания Consumer Groups и перехвата зависших сообщений

## Особенности

- ✅ **At-least-once доставка** с дедупликацией по `notification_id`
- ✅ **Идемпотентность** через заголовок `Idempotency-Key`
- ✅ **TTL 15 минут** для уведомлений с автоматической очисткой
- ✅ **Персистентность** непрочитанных сообщений между подключениями
- ✅ **Стабильные Consumer ID** для надежной доставки
- ✅ **Автоматическое восстановление** зависших сообщений

## Быстрый старт

### С Docker Compose (рекомендуется)

```bash
# Запуск всех сервисов
make docker-up

# Открыть веб-клиент в браузере
open http://localhost:8080
```

### Локальная разработка

```bash
# 1. Запустить Redis
make redis-local

# 2. Запустить сервер (в одном терминале)
make run

# 3. Запустить клиент (в другом терминале)
make client

# 4. Отправить уведомление (в третьем терминале)
make sender
```

## API

### POST /api/v1/notify

Создает уведомления для списка получателей.

**Запрос:**
```json
{
  "target": [
    {"id": 1, "login": "user1"},
    {"id": 2, "login": "user2"}
  ],
  "message": "Новое сообщение",
  "source": "chat-api",
  "created_at": "2024-01-01T12:00:00Z"
}
```

**Ответ (202 Accepted):**
```json
{
  "results": [
    {
      "target": {"id": 1, "login": "user1"},
      "notification_id": "uuid-1"
    },
    {
      "target": {"id": 2, "login": "user2"}, 
      "notification_id": "uuid-2"
    }
  ]
}
```

### WebSocket /ws

Подключение для получения уведомлений в реальном времени.

**Параметры:**
- `user_id` - ID пользователя
- `login` - логин пользователя

**Пример:** `ws://localhost:8080/ws?user_id=1&login=test_user`

## WebSocket протокол

### Сообщение от сервера (уведомление)
```json
{
  "type": "notification.push",
  "data": {
    "notification_id": "uuid",
    "stream_id": "1658926500000-0",
    "message": "Текст уведомления",
    "created_at": "2024-01-01T12:00:00Z",
    "source": "chat-api",
    "status": "unread"
  }
}
```

### Подтверждение прочтения от клиента
```json
{
  "type": "notification.read",
  "data": {
    "notification_id": "uuid",
    "stream_id": "1658926500000-0"
  }
}
```

### Подтверждение от сервера
```json
{
  "type": "notification.read.ack",
  "data": {
    "notification_id": "uuid",
    "stream_id": "1658926500000-0"
  }
}
```

## Команды Make

```bash
make help              # Показать все доступные команды
make build             # Собрать все бинарники
make run               # Запустить сервер
make client            # Запустить тестовый клиент
make client-auto       # Клиент с автоподтверждением
make sender            # Отправить тестовое уведомление
make sender-multiple   # Отправить несколько уведомлений

# Docker команды
make docker-build      # Собрать Docker образы
make docker-up         # Запустить в Docker
make docker-down       # Остановить Docker сервисы
make docker-logs       # Показать логи

# Утилиты разработки
make redis-local       # Запустить Redis локально
make redis-stop        # Остановить Redis
make clean             # Очистить бинарники
```

## Тестирование

### Веб-клиент
Откройте http://localhost:8080 для интерактивного тестирования через браузер.

### CLI клиенты

```bash
# Клиент с ручным подтверждением
./bin/client -user=1 -login=test_user

# Клиент с автоподтверждением
./bin/client -user=1 -login=test_user -auto

# Отправитель уведомлений
./bin/sender -user=1 -login=test_user -message="Hello" -count=5
```

## Структура проекта

```
.
├── cmd/                    # Точки входа приложений
│   ├── server/            # Основной сервер
│   ├── client/            # CLI клиент для тестирования
│   └── sender/            # CLI отправитель уведомлений
├── internal/              # Внутренняя логика
│   ├── config/           # Конфигурация
│   ├── domain/           # Модели и интерфейсы
│   ├── handler/          # HTTP и WebSocket обработчики
│   ├── repository/       # Слой данных (Redis)
│   ├── service/          # Бизнес-логика
│   └── worker/           # Фоновые воркеры
├── docker-compose.yaml   # Конфигурация Docker
├── Dockerfile           # Многоэтапная сборка
├── Makefile            # Команды автоматизации
└── README.md           # Документация
```

## Конфигурация

Переменные окружения:

| Переменная       | По умолчанию     | Описание            |
| ---------------- | ---------------- | ------------------- |
| `SERVER_ADDR`    | `:8080`          | Адрес HTTP сервера  |
| `REDIS_ADDR`     | `localhost:6379` | Адрес Redis сервера |
| `REDIS_PASSWORD` | (пусто)          | Пароль Redis        |

## Логирование

Используется встроенный пакет `slog` с текстовым форматированием. Уровни логирования:

- **DEBUG** - детальная отладочная информация
- **INFO** - общая информация о работе сервиса  
- **WARN** - предупреждения (не критичные ошибки)
- **ERROR** - ошибки требующие внимания

## Требования

- Go 1.25+
- Redis 6.0+ (для поддержки Streams)
- Docker и Docker Compose (для контейнеризации)

## Производительность

- Время публикации: < 50 мс на получателя (требование ТЗ)
- TTL уведомлений: 15 минут
- Блокировка WebSocket: 30 секунд
- Обслуживание групп: каждые 2 минуты
- Очистка TTL: каждую минуту

## Ограничения MVP

- Нет аутентификации/авторизации
- Нет rate limiting
- Нет метрик Prometheus
- Нет персистентного хранения метаданных
- Веб-клиент базовый (только для демо)

## Масштабирование

Для продакшена рекомендуется:

1. **Горизонтальное масштабирование**: несколько инстансов сервера
2. **Redis Cluster**: для высокой доступности
3. **Load Balancer**: с поддержкой sticky sessions для WebSocket
4. **Мониторинг**: Prometheus + Grafana для метрик
5. **Трейсинг**: OpenTelemetry для отслеживания запросов
